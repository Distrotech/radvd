
#include <assert.h>
#include <check.h>

#include "test/print_safe_buffer.h"

/*
 * http://check.sourceforge.net/doc/check_html/check_3.html
 *
 * http://entrenchant.blogspot.com/2010/08/unit-testing-in-c.html
 */

#ifndef countof
# define countof(x) (sizeof(x)/sizeof(x[0]))
#endif

typedef union {
	struct sockaddr_in6 in6;
	struct sockaddr_in in;
} sockaddr;


static struct ifaddrs * reverse_list(struct ifaddrs * list)
{
	struct ifaddrs * prev = 0;
	struct ifaddrs * cur = list;

	while (cur) {
		struct ifaddrs * next = cur->ifa_next;
		cur->ifa_next = prev;
		prev = cur;
		cur = next;
	}
	return prev;
}

int getaddrs(struct ifaddrs **ifap)
{
	struct ifaddrs * retval = 0;

	FILE * in = fopen("test/ifaddrs4096.txt", "r");
	if (in) {
		do {
			char name[100];
			int type;
			char addr_str[INET6_ADDRSTRLEN];
			int int_mask;

			char line[1024];
			char * s = fgets(line, sizeof(line), in);
			if (s) {
				int count = sscanf(s, " %s %d %s %d", name, &type, addr_str, &int_mask);
				if (count >= 3) {
					struct ifaddrs * ifa = malloc(sizeof(struct ifaddrs));

					memset(ifa, 0, sizeof(struct ifaddrs));

					ifa->ifa_name = strdup(name);
					switch (type) {
					case 4: {
						struct sockaddr_in * in;

						in = malloc(sizeof(struct sockaddr_in));

						memset(in, 0, sizeof(struct sockaddr_in));

						in->sin_family = AF_INET;

						assert(inet_pton(AF_INET, addr_str, &in->sin_addr));

						ifa->ifa_addr = (struct sockaddr *)in;
					}break;

					case 6: {
						struct sockaddr_in6 * in6;
						struct sockaddr_in6 * mask;

						in6 = malloc(sizeof(struct sockaddr_in6));
						mask = malloc(sizeof(struct sockaddr_in6));

						memset(in6, 0, sizeof(struct sockaddr_in6));
						memset(mask, 0, sizeof(struct sockaddr_in6));

						in6->sin6_family = AF_INET6;
						mask->sin6_family = AF_INET6;

						assert(inet_pton(AF_INET6, addr_str, &in6->sin6_addr));
						if (int_mask == 64) {
							assert(inet_pton(AF_INET6, "ffff:ffff:ffff:ffff::", &mask->sin6_addr));
						} else {
							assert(0);
						}

						ifa->ifa_addr = (struct sockaddr *)in6;
						ifa->ifa_netmask = (struct sockaddr *)mask;
					}break;

					default:
						abort();
					}

					ifa->ifa_next = retval;
					retval = ifa;
				}
			}
		} while (!feof(in));
		fclose(in);
	}

	retval = reverse_list(retval);
#if 0
	for (struct ifaddrs * ifa2 = retval; ifa2; ifa2 = ifa2->ifa_next) {
		char dst[INET6_ADDRSTRLEN];
		if (ifa2->ifa_addr->sa_family == AF_INET6) {
			char mask[INET6_ADDRSTRLEN];
			struct sockaddr_in6 *s6 = (struct sockaddr_in6 *)ifa2->ifa_addr;
			inet_ntop(AF_INET6, &s6->sin6_addr, dst, sizeof(dst));
			printf("%s 6 %s 64\n", ifa2->ifa_name, dst);
		}
		else if (ifa2->ifa_addr->sa_family == AF_INET) {
			struct sockaddr_in *s = (struct sockaddr_in *)ifa2->ifa_addr;
			inet_ntop(AF_INET, &s->sin_addr, dst, sizeof(dst));
			printf("%s 4 %s\n", ifa2->ifa_name, dst);
		}
	}
#endif

	*ifap = retval;

	return 0;
}

void freeaddrs(struct ifaddrs *ifa)
{
	struct ifaddrs * ifa2 = ifa;
	while (ifa2) {
		struct ifaddrs * next = ifa2->ifa_next;
		if (ifa2->ifa_addr->sa_family == AF_INET6) {
			free(ifa2->ifa_netmask);
		}
		free(ifa2->ifa_addr);
		free(ifa2->ifa_name);
		free(ifa2);
		ifa2 = next;
	}
}

START_TEST (test_decrement_lifetime)
{
	uint32_t lifetime = 10;
	decrement_lifetime(7, &lifetime);
	ck_assert_int_eq(lifetime, 3);
	decrement_lifetime(7, &lifetime);
	ck_assert_int_eq(lifetime, 0);
}
END_TEST

static struct Interface * iface = 0;

static void iface_setup(void)
{
	ck_assert_ptr_eq(0, iface);
	iface = readin_config("test/test1.conf");
	ck_assert_ptr_ne(0, iface);
}

static void iface_teardown(void)
{
	ck_assert_ptr_ne(0, iface);
	free_ifaces(iface);
	iface = 0;
}

START_TEST (test_add_ra_header)
{

	struct safe_buffer sb = SAFE_BUFFER_INIT;
	add_ra_header(&sb, &iface->ra_header_info, iface->state_info.cease_adv);

#ifdef PRINT_SAFE_BUFFER
	print_safe_buffer(&sb);
#else
	unsigned char expected[] = {
		0x86, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	};

	ck_assert_int_eq(sizeof(expected), sb.used);
	ck_assert_int_eq(0, memcmp(expected, sb.buffer, sb.used));
#endif

	safe_buffer_free(&sb);
}
END_TEST

START_TEST (test_add_prefix)
{
	ck_assert_ptr_ne(0, iface);

	struct safe_buffer sb = SAFE_BUFFER_INIT;
	add_prefix(&sb, iface->AdvPrefixList, iface->state_info.cease_adv);

#ifdef PRINT_SAFE_BUFFER
	print_safe_buffer(&sb);
#else
	unsigned char expected[] = {
		0x03, 0x04, 0x40, 0xe0, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
		0xfe, 0x80, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x03, 0x04, 0x30, 0x80, 0x00, 0x00, 0x27, 0x10,
		0x00, 0x00, 0x03, 0xe8, 0x00, 0x00, 0x00, 0x00,
		0xfe, 0x80, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x03, 0x04, 0x40, 0xc0, 0x00, 0x01, 0x51, 0x80,
		0x00, 0x00, 0x38, 0x40, 0x00, 0x00, 0x00, 0x00,
		0xfe, 0x80, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	};

	ck_assert_int_eq(sizeof(expected), sb.used);
	ck_assert_int_eq(0, memcmp(expected, sb.buffer, sb.used));
#endif

	safe_buffer_free(&sb);
}
END_TEST

START_TEST (test_add_prefix_auto_zero)
{
	static struct Interface * iface_auto = 0;
	iface_auto = readin_config("test/test_auto_zero.conf");
	ck_assert_ptr_ne(0, iface_auto);

	set_debuglevel(5);
	log_open(L_STDERR, "test", 0, 0);

	struct safe_buffer sb = SAFE_BUFFER_INIT;
	build_ra(&sb, iface_auto);
#ifdef PRINT_SAFE_BUFFER
	print_safe_buffer(&sb);
#else
	unsigned char expected[] = {
		0x86, 0x00, 0x00, 0x00, 0x40, 0x00, 0xff, 0xff,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x03, 0x04, 0x40, 0xe0, 0x00, 0x01, 0x51, 0x80,
		0x00, 0x00, 0x38, 0x40, 0x00, 0x00, 0x00, 0x00,
		0x20, 0x01, 0xfe, 0xed, 0x00, 0x00, 0x00, 0x07,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x03, 0x04, 0x40, 0xe0, 0x00, 0x01, 0x51, 0x80,
		0x00, 0x00, 0x38, 0x40, 0x00, 0x00, 0x00, 0x00,
		0x20, 0x01, 0xca, 0xfe, 0x00, 0x00, 0x00, 0x07,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x03, 0x04, 0x40, 0xe0, 0x00, 0x01, 0x51, 0x80,
		0x00, 0x00, 0x38, 0x40, 0x00, 0x00, 0x00, 0x00,
		0x20, 0x01, 0xf0, 0x0d, 0x00, 0x00, 0x00, 0x07,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x05, 0x01, 0x00, 0x00, 0x00, 0x00, 0x04, 0xd2,
	};

	ck_assert_int_eq(sizeof(expected), sb.used);
	ck_assert_int_eq(0, memcmp(expected, sb.buffer, sb.used));
#endif

	safe_buffer_free(&sb);
	free_ifaces(iface_auto);
}
END_TEST


START_TEST (test_add_prefix_auto_base6)
{
	static struct Interface * iface_auto = 0;
	iface_auto = readin_config("test/test_auto_base6.conf");
	ck_assert_ptr_ne(0, iface_auto);

	set_debuglevel(5);
	log_open(L_STDERR, "test", 0, 0);

	struct safe_buffer sb = SAFE_BUFFER_INIT;
	build_ra(&sb, iface_auto);

#ifdef PRINT_SAFE_BUFFER
	print_safe_buffer(&sb);
#else
	unsigned char expected[] = {
		0x86, 0x00, 0x00, 0x00, 0x40, 0x00, 0xff, 0xff,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x03, 0x04, 0x40, 0xe0, 0x00, 0x01, 0x51, 0x80,
		0x00, 0x00, 0x38, 0x40, 0x00, 0x00, 0x00, 0x00,
		0x20, 0x01, 0xfe, 0xed, 0x00, 0x00, 0x00, 0x05,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x03, 0x04, 0x40, 0xe0, 0x00, 0x01, 0x51, 0x80,
		0x00, 0x00, 0x38, 0x40, 0x00, 0x00, 0x00, 0x00,
		0x20, 0x01, 0xca, 0xfe, 0x00, 0x00, 0x00, 0x05,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x03, 0x04, 0x40, 0xe0, 0x00, 0x01, 0x51, 0x80,
		0x00, 0x00, 0x38, 0x40, 0x00, 0x00, 0x00, 0x00,
		0x20, 0x01, 0xf0, 0x0d, 0x00, 0x00, 0x00, 0x05,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x03, 0x04, 0x40, 0xe0, 0x00, 0x01, 0x51, 0x80,
		0x00, 0x00, 0x38, 0x40, 0x00, 0x00, 0x00, 0x00,
		0x20, 0x01, 0xfe, 0xed, 0x00, 0x00, 0x00, 0x04,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x03, 0x04, 0x40, 0xe0, 0x00, 0x01, 0x51, 0x80,
		0x00, 0x00, 0x38, 0x40, 0x00, 0x00, 0x00, 0x00,
		0x20, 0x01, 0xca, 0xfe, 0x00, 0x00, 0x00, 0x04,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x03, 0x04, 0x40, 0xe0, 0x00, 0x01, 0x51, 0x80,
		0x00, 0x00, 0x38, 0x40, 0x00, 0x00, 0x00, 0x00,
		0x20, 0x01, 0xf0, 0x0d, 0x00, 0x00, 0x00, 0x04,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x05, 0x01, 0x00, 0x00, 0x00, 0x00, 0x04, 0xd2,
	};

	ck_assert_int_eq(sizeof(expected), sb.used);
	ck_assert_int_eq(0, memcmp(expected, sb.buffer, sb.used));
#endif

	safe_buffer_free(&sb);
	free_ifaces(iface_auto);
}
END_TEST


START_TEST (test_add_prefix_auto_base6to4)
{
	static struct Interface * iface_auto = 0;
	iface_auto = readin_config("test/test_auto_base6to4.conf");
	ck_assert_ptr_ne(0, iface_auto);

	set_debuglevel(5);
	log_open(L_STDERR, "test", 0, 0);

	struct safe_buffer sb = SAFE_BUFFER_INIT;
	build_ra(&sb, iface_auto);

#ifdef PRINT_SAFE_BUFFER
	print_safe_buffer(&sb);
#else
	unsigned char expected[] = {
		0x86, 0x00, 0x00, 0x00, 0x40, 0x00, 0xff, 0xff,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x03, 0x04, 0x40, 0xe0, 0x00, 0x01, 0x51, 0x80,
		0x00, 0x00, 0x38, 0x40, 0x00, 0x00, 0x00, 0x00,
		0x20, 0x02, 0x0c, 0x00, 0x00, 0x03, 0x33, 0x33,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x03, 0x04, 0x40, 0xe0, 0x00, 0x01, 0x51, 0x80,
		0x00, 0x00, 0x38, 0x40, 0x00, 0x00, 0x00, 0x00,
		0x20, 0x02, 0x0b, 0x00, 0x00, 0x03, 0x33, 0x33,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x03, 0x04, 0x40, 0xe0, 0x00, 0x01, 0x51, 0x80,
		0x00, 0x00, 0x38, 0x40, 0x00, 0x00, 0x00, 0x00,
		0x20, 0x02, 0x0a, 0x00, 0x00, 0x03, 0x33, 0x33,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x03, 0x04, 0x40, 0xe0, 0x00, 0x01, 0x51, 0x80,
		0x00, 0x00, 0x38, 0x40, 0x00, 0x00, 0x00, 0x00,
		0x20, 0x02, 0x0c, 0x00, 0x00, 0x02, 0x22, 0x22,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x03, 0x04, 0x40, 0xe0, 0x00, 0x01, 0x51, 0x80,
		0x00, 0x00, 0x38, 0x40, 0x00, 0x00, 0x00, 0x00,
		0x20, 0x02, 0x0b, 0x00, 0x00, 0x02, 0x22, 0x22,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x03, 0x04, 0x40, 0xe0, 0x00, 0x01, 0x51, 0x80,
		0x00, 0x00, 0x38, 0x40, 0x00, 0x00, 0x00, 0x00,
		0x20, 0x02, 0x0a, 0x00, 0x00, 0x02, 0x22, 0x22,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x05, 0x01, 0x00, 0x00, 0x00, 0x00, 0x04, 0xd2,
	};

	ck_assert_int_eq(sizeof(expected), sb.used);
	ck_assert_int_eq(0, memcmp(expected, sb.buffer, sb.used));
#endif

	safe_buffer_free(&sb);
	free_ifaces(iface_auto);
}
END_TEST


START_TEST (test_add_prefix_auto)
{
	static struct Interface * iface_auto = 0;
	iface_auto = readin_config("test/test_auto.conf");
	ck_assert_ptr_ne(0, iface_auto);

	set_debuglevel(5);
	log_open(L_STDERR, "test", 0, 0);

	struct safe_buffer sb = SAFE_BUFFER_INIT;
	build_ra(&sb, iface_auto);

#ifdef PRINT_SAFE_BUFFER
	print_safe_buffer(&sb);
#else
	unsigned char expected[] = {
		0x86, 0x00, 0x00, 0x00, 0x40, 0x00, 0xff, 0xff,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x03, 0x04, 0x40, 0xe0, 0x00, 0x01, 0x51, 0x80,
		0x00, 0x00, 0x38, 0x40, 0x00, 0x00, 0x00, 0x00,
		0x20, 0x02, 0x0c, 0x00, 0x00, 0x03, 0x64, 0x64,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x03, 0x04, 0x40, 0xe0, 0x00, 0x01, 0x51, 0x80,
		0x00, 0x00, 0x38, 0x40, 0x00, 0x00, 0x00, 0x00,
		0x20, 0x02, 0x0b, 0x00, 0x00, 0x03, 0x64, 0x64,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x03, 0x04, 0x40, 0xe0, 0x00, 0x01, 0x51, 0x80,
		0x00, 0x00, 0x38, 0x40, 0x00, 0x00, 0x00, 0x00,
		0x20, 0x02, 0x0a, 0x00, 0x00, 0x03, 0x64, 0x64,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x03, 0x04, 0x40, 0xe0, 0x00, 0x01, 0x51, 0x80,
		0x00, 0x00, 0x38, 0x40, 0x00, 0x00, 0x00, 0x00,
		0x20, 0x02, 0x0c, 0x00, 0x00, 0x01, 0x66, 0x44,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x03, 0x04, 0x40, 0xe0, 0x00, 0x01, 0x51, 0x80,
		0x00, 0x00, 0x38, 0x40, 0x00, 0x00, 0x00, 0x00,
		0x20, 0x02, 0x0b, 0x00, 0x00, 0x01, 0x66, 0x44,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x03, 0x04, 0x40, 0xe0, 0x00, 0x01, 0x51, 0x80,
		0x00, 0x00, 0x38, 0x40, 0x00, 0x00, 0x00, 0x00,
		0x20, 0x02, 0x0a, 0x00, 0x00, 0x01, 0x66, 0x44,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x03, 0x04, 0x40, 0xe0, 0x00, 0x01, 0x51, 0x80,
		0x00, 0x00, 0x38, 0x40, 0x00, 0x00, 0x00, 0x00,
		0x20, 0x01, 0xfe, 0xed, 0x00, 0x00, 0x00, 0x03,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x03, 0x04, 0x40, 0xe0, 0x00, 0x01, 0x51, 0x80,
		0x00, 0x00, 0x38, 0x40, 0x00, 0x00, 0x00, 0x00,
		0x20, 0x01, 0xca, 0xfe, 0x00, 0x00, 0x00, 0x03,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x03, 0x04, 0x40, 0xe0, 0x00, 0x01, 0x51, 0x80,
		0x00, 0x00, 0x38, 0x40, 0x00, 0x00, 0x00, 0x00,
		0x20, 0x01, 0xf0, 0x0d, 0x00, 0x00, 0x00, 0x03,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x03, 0x04, 0x40, 0xe0, 0x00, 0x01, 0x51, 0x80,
		0x00, 0x00, 0x38, 0x40, 0x00, 0x00, 0x00, 0x00,
		0x20, 0x01, 0xfe, 0xed, 0x00, 0x00, 0x00, 0x02,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x03, 0x04, 0x40, 0xe0, 0x00, 0x01, 0x51, 0x80,
		0x00, 0x00, 0x38, 0x40, 0x00, 0x00, 0x00, 0x00,
		0x20, 0x01, 0xca, 0xfe, 0x00, 0x00, 0x00, 0x02,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x03, 0x04, 0x40, 0xe0, 0x00, 0x01, 0x51, 0x80,
		0x00, 0x00, 0x38, 0x40, 0x00, 0x00, 0x00, 0x00,
		0x20, 0x01, 0xf0, 0x0d, 0x00, 0x00, 0x00, 0x02,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x03, 0x04, 0x40, 0xe0, 0x00, 0x01, 0x51, 0x80,
		0x00, 0x00, 0x38, 0x40, 0x00, 0x00, 0x00, 0x00,
		0x20, 0x01, 0xfe, 0xed, 0x00, 0x00, 0x00, 0x08,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x03, 0x04, 0x40, 0xe0, 0x00, 0x01, 0x51, 0x80,
		0x00, 0x00, 0x38, 0x40, 0x00, 0x00, 0x00, 0x00,
		0x20, 0x01, 0xca, 0xfe, 0x00, 0x00, 0x00, 0x08,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x03, 0x04, 0x40, 0xe0, 0x00, 0x01, 0x51, 0x80,
		0x00, 0x00, 0x38, 0x40, 0x00, 0x00, 0x00, 0x00,
		0x20, 0x01, 0xf0, 0x0d, 0x00, 0x00, 0x00, 0x08,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x05, 0x01, 0x00, 0x00, 0x00, 0x00, 0x04, 0xd2,
	};

	ck_assert_int_eq(sizeof(expected), sb.used);
	ck_assert_int_eq(0, memcmp(expected, sb.buffer, sb.used));
#endif

	safe_buffer_free(&sb);

	sb = SAFE_BUFFER_INIT;
	build_ra(&sb, iface_auto->next);

#ifdef PRINT_SAFE_BUFFER
	print_safe_buffer(&sb);
#else
	unsigned char expected2[] = {
		0x86, 0x00, 0x00, 0x00, 0x40, 0x00, 0xff, 0xff,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x03, 0x04, 0x40, 0xe0, 0x00, 0x01, 0x51, 0x80,
		0x00, 0x00, 0x38, 0x40, 0x00, 0x00, 0x00, 0x00,
		0x20, 0x02, 0x0c, 0x00, 0x00, 0x0c, 0x64, 0x64,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x03, 0x04, 0x40, 0xe0, 0x00, 0x01, 0x51, 0x80,
		0x00, 0x00, 0x38, 0x40, 0x00, 0x00, 0x00, 0x00,
		0x20, 0x02, 0x0b, 0x00, 0x00, 0x0c, 0x64, 0x64,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x03, 0x04, 0x40, 0xe0, 0x00, 0x01, 0x51, 0x80,
		0x00, 0x00, 0x38, 0x40, 0x00, 0x00, 0x00, 0x00,
		0x20, 0x02, 0x0a, 0x00, 0x00, 0x0c, 0x64, 0x64,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x03, 0x04, 0x40, 0xe0, 0x00, 0x01, 0x51, 0x80,
		0x00, 0x00, 0x38, 0x40, 0x00, 0x00, 0x00, 0x00,
		0x20, 0x02, 0x0c, 0x00, 0x00, 0x09, 0x66, 0x44,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x03, 0x04, 0x40, 0xe0, 0x00, 0x01, 0x51, 0x80,
		0x00, 0x00, 0x38, 0x40, 0x00, 0x00, 0x00, 0x00,
		0x20, 0x02, 0x0b, 0x00, 0x00, 0x09, 0x66, 0x44,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x03, 0x04, 0x40, 0xe0, 0x00, 0x01, 0x51, 0x80,
		0x00, 0x00, 0x38, 0x40, 0x00, 0x00, 0x00, 0x00,
		0x20, 0x02, 0x0a, 0x00, 0x00, 0x09, 0x66, 0x44,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x03, 0x04, 0x40, 0xe0, 0x00, 0x01, 0x51, 0x80,
		0x00, 0x00, 0x38, 0x40, 0x00, 0x00, 0x00, 0x00,
		0x20, 0x01, 0xfe, 0xed, 0x00, 0x00, 0x00, 0x0e,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x03, 0x04, 0x40, 0xe0, 0x00, 0x01, 0x51, 0x80,
		0x00, 0x00, 0x38, 0x40, 0x00, 0x00, 0x00, 0x00,
		0x20, 0x01, 0xca, 0xfe, 0x00, 0x00, 0x00, 0x0e,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x03, 0x04, 0x40, 0xe0, 0x00, 0x01, 0x51, 0x80,
		0x00, 0x00, 0x38, 0x40, 0x00, 0x00, 0x00, 0x00,
		0x20, 0x01, 0xf0, 0x0d, 0x00, 0x00, 0x00, 0x0e,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x03, 0x04, 0x40, 0xe0, 0x00, 0x01, 0x51, 0x80,
		0x00, 0x00, 0x38, 0x40, 0x00, 0x00, 0x00, 0x00,
		0x20, 0x01, 0xfe, 0xed, 0x00, 0x00, 0x00, 0x07,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x03, 0x04, 0x40, 0xe0, 0x00, 0x01, 0x51, 0x80,
		0x00, 0x00, 0x38, 0x40, 0x00, 0x00, 0x00, 0x00,
		0x20, 0x01, 0xca, 0xfe, 0x00, 0x00, 0x00, 0x07,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x03, 0x04, 0x40, 0xe0, 0x00, 0x01, 0x51, 0x80,
		0x00, 0x00, 0x38, 0x40, 0x00, 0x00, 0x00, 0x00,
		0x20, 0x01, 0xf0, 0x0d, 0x00, 0x00, 0x00, 0x07,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x03, 0x04, 0x40, 0xe0, 0x00, 0x01, 0x51, 0x80,
		0x00, 0x00, 0x38, 0x40, 0x00, 0x00, 0x00, 0x00,
		0x20, 0x01, 0xfe, 0xed, 0x00, 0x00, 0x00, 0x0b,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x03, 0x04, 0x40, 0xe0, 0x00, 0x01, 0x51, 0x80,
		0x00, 0x00, 0x38, 0x40, 0x00, 0x00, 0x00, 0x00,
		0x20, 0x01, 0xca, 0xfe, 0x00, 0x00, 0x00, 0x0b,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x03, 0x04, 0x40, 0xe0, 0x00, 0x01, 0x51, 0x80,
		0x00, 0x00, 0x38, 0x40, 0x00, 0x00, 0x00, 0x00,
		0x20, 0x01, 0xf0, 0x0d, 0x00, 0x00, 0x00, 0x0b,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x03, 0x04, 0x40, 0xe0, 0x00, 0x01, 0x51, 0x80,
		0x00, 0x00, 0x38, 0x40, 0x00, 0x00, 0x00, 0x00,
		0x20, 0x01, 0xfe, 0xed, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x03, 0x04, 0x40, 0xe0, 0x00, 0x01, 0x51, 0x80,
		0x00, 0x00, 0x38, 0x40, 0x00, 0x00, 0x00, 0x00,
		0x20, 0x01, 0xca, 0xfe, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x03, 0x04, 0x40, 0xe0, 0x00, 0x01, 0x51, 0x80,
		0x00, 0x00, 0x38, 0x40, 0x00, 0x00, 0x00, 0x00,
		0x20, 0x01, 0xf0, 0x0d, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x05, 0x01, 0x00, 0x00, 0x00, 0x00, 0x04, 0xd2,
	};
	ck_assert_int_eq(sizeof(expected2), sb.used);
	ck_assert_int_eq(0, memcmp(expected2, sb.buffer, sb.used));
#endif

	safe_buffer_free(&sb);
	free_ifaces(iface_auto);
}
END_TEST

START_TEST (test_add_route)
{
	ck_assert_ptr_ne(0, iface);

	struct safe_buffer sb = SAFE_BUFFER_INIT;
	add_route(&sb, iface->AdvRouteList, iface->state_info.cease_adv);

#ifdef PRINT_SAFE_BUFFER
	print_safe_buffer(&sb);
#else
	unsigned char expected[] = {
		0x18, 0x03, 0x30, 0x18, 0x00, 0x00, 0x27, 0x10,
		0xfe, 0x80, 0x00, 0x0f, 0x00, 0x01, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x18, 0x03, 0x28, 0x08, 0xff, 0xff, 0xff, 0xff,
		0xfe, 0x80, 0x00, 0x0f, 0x00, 0x02, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x18, 0x03, 0x20, 0x00, 0x00, 0x00, 0x0b, 0xb8,
		0xfe, 0x80, 0x00, 0x0f, 0x00, 0x02, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	};

	ck_assert_int_eq(sizeof(expected), sb.used);
	ck_assert_int_eq(0, memcmp(expected, sb.buffer, sb.used));
#endif
	safe_buffer_free(&sb);
}
END_TEST


START_TEST (test_add_rdnss)
{
	ck_assert_ptr_ne(0, iface);

	struct safe_buffer sb = SAFE_BUFFER_INIT;
	add_rdnss(&sb, iface->AdvRDNSSList, iface->state_info.cease_adv);

#ifdef PRINT_SAFE_BUFFER
	print_safe_buffer(&sb);
#else
	unsigned char expected[] = {
		0x19, 0x07, 0x00, 0x00, 0x00, 0x00, 0x04, 0xd2,
		0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
		0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
		0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,
	};

	ck_assert_int_eq(sizeof(expected), sb.used);
	ck_assert_int_eq(0, memcmp(expected, sb.buffer, sb.used));
#endif

	safe_buffer_free(&sb);
}
END_TEST


START_TEST (test_add_rdnss2)
{
	static struct Interface * iface = 0;
	iface = readin_config("test/test_rdnss.conf");
	ck_assert_ptr_ne(0, iface);

	struct safe_buffer sb = SAFE_BUFFER_INIT;
	add_rdnss(&sb, iface->AdvRDNSSList, iface->state_info.cease_adv);
	free_ifaces(iface);

#ifdef PRINT_SAFE_BUFFER
	print_safe_buffer(&sb);
#else
	unsigned char expected[] = {
		0x19, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2d,
		0x12, 0x34, 0x04, 0x23, 0xfe, 0xfe, 0x04, 0x93,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
	};

	ck_assert_int_eq(sizeof(expected), sb.used);
	ck_assert_int_eq(0, memcmp(expected, sb.buffer, sb.used));
#endif

	safe_buffer_free(&sb);
}
END_TEST


START_TEST (test_add_dnssl)
{
	ck_assert_ptr_ne(0, iface);

	struct safe_buffer sb = SAFE_BUFFER_INIT;
	add_dnssl(&sb, iface->AdvDNSSLList, iface->state_info.cease_adv);

#ifdef PRINT_SAFE_BUFFER
	print_safe_buffer(&sb);
#else
	unsigned char expected[] = {
		0x1f, 0x09, 0x00, 0x00, 0x00, 0x00, 0x03, 0xe8,
		0x06, 0x6f, 0x66, 0x66, 0x69, 0x63, 0x65, 0x06,
		0x62, 0x72, 0x61, 0x6e, 0x63, 0x68, 0x07, 0x65,
		0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x03, 0x63,
		0x6f, 0x6d, 0x00, 0x06, 0x62, 0x72, 0x61, 0x6e,
		0x63, 0x68, 0x07, 0x65, 0x78, 0x61, 0x6d, 0x70,
		0x6c, 0x65, 0x03, 0x63, 0x6f, 0x6d, 0x00, 0x07,
		0x65, 0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x03,
		0x63, 0x6f, 0x6d, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x1f, 0x09, 0x00, 0x00, 0x00, 0x00, 0x04, 0x4b,
		0x06, 0x6f, 0x66, 0x66, 0x69, 0x63, 0x65, 0x06,
		0x62, 0x72, 0x61, 0x6e, 0x63, 0x68, 0x07, 0x65,
		0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x03, 0x6e,
		0x65, 0x74, 0x00, 0x06, 0x62, 0x72, 0x61, 0x6e,
		0x63, 0x68, 0x07, 0x65, 0x78, 0x61, 0x6d, 0x70,
		0x6c, 0x65, 0x03, 0x6e, 0x65, 0x74, 0x00, 0x07,
		0x65, 0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x03,
		0x6e, 0x65, 0x74, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x1f, 0x07, 0x00, 0x00, 0x00, 0x00, 0x04, 0x4c,
		0x06, 0x6f, 0x66, 0x66, 0x69, 0x63, 0x65, 0x06,
		0x62, 0x72, 0x61, 0x6e, 0x63, 0x68, 0x07, 0x65,
		0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x00, 0x06,
		0x62, 0x72, 0x61, 0x6e, 0x63, 0x68, 0x07, 0x65,
		0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x00, 0x07,
		0x65, 0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x00,
	};

	ck_assert_int_eq(sizeof(expected), sb.used);
	ck_assert_int_eq(0, memcmp(expected, sb.buffer, sb.used));
#endif

	safe_buffer_free(&sb);
}
END_TEST


START_TEST (test_add_mtu)
{
	ck_assert_ptr_ne(0, iface);

	struct safe_buffer sb = SAFE_BUFFER_INIT;
	add_mtu(&sb, iface->AdvLinkMTU);

#ifdef PRINT_SAFE_BUFFER
	print_safe_buffer(&sb);
#else
	unsigned char expected[] = {
		0x05, 0x01, 0x00, 0x00, 0x00, 0x00, 0x04, 0xd2,
	};

	ck_assert_int_eq(sb.used, sizeof(expected));
	ck_assert_int_eq(0, memcmp(expected, sb.buffer, sizeof(expected)));
#endif

	safe_buffer_free(&sb);
}
END_TEST

START_TEST (test_add_sllao)
{
	struct sllao sllao48 = {
		{1, 2, 3, 4, 5, 6, 7, 8},
		48,
		64,
		1500,
	};
	
	struct safe_buffer sb = SAFE_BUFFER_INIT;
	add_sllao(&sb, &sllao48);

#ifdef PRINT_SAFE_BUFFER
	print_safe_buffer(&sb);
#else
	unsigned char expected48[] = {
		0x01, 0x01, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06,
	};

	ck_assert_int_eq(sizeof(expected48), sb.used);
	ck_assert_int_eq(0, memcmp(sb.buffer, expected48, sizeof(expected48)));
#endif

	safe_buffer_free(&sb);

	struct sllao sllao64 = {
		{1, 2, 3, 4, 5, 6, 7, 8},
		64,
		64,
		1500,
	};
	
	sb = SAFE_BUFFER_INIT;
	add_sllao(&sb, &sllao64);

#ifdef PRINT_SAFE_BUFFER
	print_safe_buffer(&sb);
#else
	unsigned char expected64[] = {
		0x01, 0x02, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06,
		0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	};

	ck_assert_int_eq(sizeof(expected64), sb.used);
	ck_assert_int_eq(0, memcmp(sb.buffer, expected64, sizeof(expected64)));
#endif

	safe_buffer_free(&sb);
}
END_TEST

START_TEST (test_add_lowpanco)
{
	ck_assert_ptr_ne(0, iface);

	struct safe_buffer sb = SAFE_BUFFER_INIT;
	add_lowpanco(&sb, iface->AdvLowpanCoList);

#ifdef PRINT_SAFE_BUFFER
	print_safe_buffer(&sb);
#else
	unsigned char expected[] = {
		0x22, 0x03, 0x32, 0x48, 0x00, 0x00, 0xe8, 0x03,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	};

	ck_assert_int_eq(sb.used, sizeof(expected));
	ck_assert_int_eq(0, memcmp(expected, sb.buffer, sizeof(expected)));
#endif

	safe_buffer_free(&sb);
}
END_TEST


START_TEST (test_add_abro)
{
	ck_assert_ptr_ne(0, iface);

	struct safe_buffer sb = SAFE_BUFFER_INIT;
	add_abro(&sb, iface->AdvAbroList);

#ifdef PRINT_SAFE_BUFFER
	print_safe_buffer(&sb);
#else
	unsigned char expected[] = {
		0x23, 0x03, 0x0a, 0x00, 0x02, 0x00, 0x02, 0x00,
		0xfe, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xa2, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
	};

	ck_assert_int_eq(sb.used, sizeof(expected));
	ck_assert_int_eq(0, memcmp(expected, sb.buffer, sizeof(expected)));
#endif

	safe_buffer_free(&sb);
}
END_TEST


Suite * send_suite(void)
{
	set_debuglevel(5);
	log_open(L_STDERR, "test", 0, 0);

	TCase * tc_update = tcase_create("update");
	tcase_add_test(tc_update, test_decrement_lifetime);

	TCase * tc_auto = tcase_create("auto");
	tcase_add_test(tc_auto, test_add_prefix_auto_zero);
	tcase_add_test(tc_auto, test_add_prefix_auto_base6);
	tcase_add_test(tc_auto, test_add_prefix_auto_base6to4);
	tcase_add_test(tc_auto, test_add_prefix_auto);

	TCase * tc_build = tcase_create("build");
	tcase_add_unchecked_fixture(tc_build, iface_setup, iface_teardown);
	tcase_add_test(tc_build, test_add_ra_header);
	tcase_add_test(tc_build, test_add_prefix);
	tcase_add_test(tc_build, test_add_route);
	tcase_add_test(tc_build, test_add_rdnss);
	tcase_add_test(tc_build, test_add_rdnss2);
	tcase_add_test(tc_build, test_add_dnssl);
	tcase_add_test(tc_build, test_add_mtu);
	tcase_add_test(tc_build, test_add_sllao);
	tcase_add_test(tc_build, test_add_lowpanco);
	tcase_add_test(tc_build, test_add_abro);

	Suite *s = suite_create("send");
	suite_add_tcase(s, tc_update);
	suite_add_tcase(s, tc_build);
	suite_add_tcase(s, tc_auto);

	return s;	
}

